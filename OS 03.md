## Teaching Material: **Processes and Interprocess Communication**

---

### **1. Process Concept**
- **Process**: A program in execution, consisting of:
  - **Text Section**: The program code.
  - **Program Counter**: The current activity (e.g., the next instruction).
  - **Stack**: Contains temporary data (function parameters, return addresses, local variables).
  - **Data Section**: Global variables.
  - **Heap**: Dynamically allocated memory during runtime.

**Example**: Running a Python program initiates a process with the program's code, data, and variables loaded into memory.

---

### **2. Process States**
A process goes through several states during execution:
- **New**: The process is being created.
- **Running**: The process is executing.
- **Waiting**: The process is waiting for some event (e.g., I/O).
- **Ready**: The process is ready and waiting for CPU time.
- **Terminated**: The process has finished execution.

**Example**: When running a file transfer, it may move from "running" to "waiting" (for I/O completion) to "ready" and back to "running".

---

### **3. Process Control Block (PCB)**
Each process is represented in the OS by a PCB, containing:
- **Process State**: Running, waiting, etc.
- **Program Counter**: Next instruction to execute.
- **CPU Registers**: Process-specific information.
- **Scheduling Information**: Process priority, etc.
- **Memory Management Info**: Memory allocated to the process.
- **I/O Status**: Information about I/O devices used by the process.

---

### **4. Process Scheduling**
- The OS schedules processes based on their states and ensures efficient CPU usage.
- **Ready Queue**: Holds processes ready for execution.
- **Wait Queue**: Holds processes waiting for an event (e.g., I/O).

**Example**: In a system where multiple applications are open, the OS uses scheduling to switch between them, ensuring no application starves.

---

### **5. Context Switching**
When the CPU switches from one process to another, it saves the state of the old process and loads the saved state for the new process. This is called a **context switch**. This switching adds overhead but is necessary for multitasking.

---

### **6. Operations on Processes**

#### **6.1. Process Creation**
- **Parent Process**: Creates a child process, forming a process tree.
- **Resource Sharing**: Parent and child may share resources, or have separate resources.
  
**UNIX Example**:
- **fork()**: Creates a new process.
- **exec()**: Replaces the process memory space with a new program.
  
**Example**: A shell process (parent) forks a new process (child) to run a command.

#### **6.2. Process Termination**
- **exit()**: Process finishes execution and releases resources.
- **wait()**: Parent waits for child to terminate.
- **Orphan/Zombie Processes**: Processes that continue running after the parent exits or die but are not removed.

---

### **7. Interprocess Communication (IPC)**
Processes often need to communicate, especially when they are cooperating (e.g., sharing data). There are two primary IPC models:

#### **7.1. Shared Memory**
- Processes share a portion of memory and communicate by reading/writing to this shared space.
- Synchronization is critical to avoid race conditions when multiple processes access the shared memory simultaneously.

**Example**: Producer-consumer problem solved using shared memory. The producer fills a buffer, and the consumer reads from it.

#### **7.2. Message Passing**
- Processes communicate by sending and receiving messages.
- Messages can be passed directly between processes or through mailboxes/ports.
  
**Example**: In a client-server model, the client sends a request (message) to the server and waits for a reply.

---

### **8. Synchronization and Race Conditions**
- **Race Condition**: Occurs when multiple processes try to change shared data simultaneously, leading to inconsistent results.

**Example**: In the producer-consumer problem, without proper synchronization, the producer and consumer might overwrite each other's work.

---

### **9. IPC Mechanisms**

#### **9.1. Pipes**
- **Ordinary Pipes**: Unidirectional and require a parent-child relationship between communicating processes.
- **Named Pipes**: More powerful, bidirectional, and don't require parent-child relationships.

**Example**: Linux commands like `ls | grep` use a pipe to pass the output of `ls` to `grep`.

#### **9.2. Sockets**
- A **socket** is an endpoint for communication between two machines, identified by an IP address and a port number.
  
**Example**: Web servers use sockets to communicate with browsers via HTTP.

#### **9.3. Remote Procedure Calls (RPC)**
- **RPC**: Allows processes to call functions on a remote server, abstracting the details of communication.
  
**Example**: A database client calls a query function on a remote database server via RPC.

---

### **10. Examples of IPC Systems**

#### **10.1. POSIX Shared Memory**
- **shm_open()**: Creates or opens a shared memory object.
- **mmap()**: Maps the shared memory object into the address space of the process.

#### **10.2. Mach Message Passing**
- **Mach** uses message-based communication, where even system calls are sent as messages.

#### **10.3. Windows Local Procedure Calls (LPC)**
- LPC enables processes on the same machine to communicate using ports (like mailboxes).

